from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Any, Generic, TypeVar

# TypeVar используется для указания обобщенного типа (Generic). VT (Value Type) - это тип данных,
# с которым будет работать данный класс. 'bound=Any' означает, что VT может быть любым типом.
VT = TypeVar('VT', bound=Any)


# @dataclass автоматизирует создание стандартных методов для класса (например, __init__, __repr__, __eq__).
# frozen=True делает объект неизменяемым (immutable), что часто используется для Value Objects,
# так как это помогает избежать изменения значения после создания объекта. Если убрать frozen=True,
# то объекты этого класса можно будет изменять после создания.
@dataclass(frozen=True)
class BaseValueObject(ABC, Generic[VT]):
    """
    Generic[VT] - обьект знаачение
    Generic[VT] позволяет делать класс обобщённым, что даёт возможность
    использовать его с разными типами данных, оставаясь типобезопасным.
    Например,
      BaseValueObject может быть использован как для строк,
      так и для чисел — просто нужно создать конкретный класс-наследник, который укажет тип для VT.
    """
    # Поле value хранит значение типа VT. Оно задается при создании объекта.
    value: VT

    def __post_init__(self):
        return self.validate()

    # abstractmethod указывает, что этот метод должен быть реализован в классах-наследниках.
    # Это обязывает разработчика реализовать логику валидации для конкретного объекта значения.
    @abstractmethod
    def validate(self):
        pass

    # Ещё один абстрактный метод, который обязан быть реализован в наследниках.
    # Предполагается, что он будет использоваться для преобразования объекта в обобщённый (generic) тип.
    @abstractmethod
    def as_generic_type(self):
        pass

    # __eq__ и __hash__ включены автоматически благодаря @dataclass.
    # Это стандартные методы, которые используются для сравнения объектов и их использования в хэш-таблицах (например, словарях).

    # __eq__ сравнивает объекты на основе значений их атрибутов. Если значение одного объекта равно значению другого,
    # объекты считаются равными.

    # __hash__ создает хэш-код для объекта, используя его атрибуты (в данном случае атрибут value).
    # Это делает объекты пригодными для использования в таких коллекциях, как словари (dict) и множества (set).

######################################################
######### Пример использования с классом Age #########
######################################################

# @dataclass(frozen=True)
# class Age(BaseValueObject[int]):
#     def validate(self):
#         if self.value < 0:
#             raise ValueError("Age cannot be negative")
#         if self.value > 150:
#             raise ValueError("Age is unrealistically high")
#
#     def as_generic_type(self):
#         return f"Age: {self.value}"
#
#
# # Создание двух объектов Age
# age1 = Age(value=25)
# age2 = Age(value=25)
#
# # Сравнение объектов
# print(age1 == age2)  # True, так как у них одинаковые значения.
#
# # Попытка изменить значение вызовет ошибку, так как объект заморожен (frozen).
# # age1.value = 30  # Ошибка: 'Age' object is frozen.
#
# # Теперь создадим словарь с объектами Age в качестве ключей.
# age_dict = {age1: "First", age2: "Second"}
# print(age_dict)  # {Age(value=25): 'Second'}
# print(age_dict[Age(25)])  # 'Second'
#
# # Почему так произошло:
# # В словарях (dict) Python ключи должны быть уникальными, и сравнение ключей происходит через методы __eq__ и __hash__.
# # Поскольку у age1 и age2 одинаковое значение (25), они считаются равными (__eq__), и их хэш-коды также совпадают (__hash__).
# # Когда в словарь добавляется age2 с тем же значением, что и age1, age2 заменяет age1.
# # В итоге словарь будет иметь один ключ с значением 25 и значением "Second".
