# Domain-Driven Design (DDD)

**Domain-Driven Design (DDD)** — это подход к разработке программного обеспечения, при котором внимание сосредоточено на основной бизнес-логике и доменной области приложения. DDD помогает разделить сложную бизнес-логику на более простые и управляемые части.

## Основные концепции DDD:
![img.png](imgs/img.png) 

В данном проекте мы следуем принципам Domain-Driven Design (DDD) для четкого разделения ответственности между компонентами. Структура проекта позволяет организовать код так, чтобы каждая часть отвечала за свою область, что значительно упрощает поддержку и расширение приложения. Ниже описаны уровни логики и их роль в системе.

### 1. **Entities (Сущности, Domain Logic)**

   - **Описание**: Сущности представляют объекты реального мира, такие как пользователи, заказы и т.д. Они имеют уникальный идентификатор и сохраняют свою идентичность на протяжении времени.
   - **Реализация**: В папке `domain` хранятся классы, которые описывают бизнес-сущности и их атрибуты. Эти сущности также могут содержать методы, которые отражают поведение этих объектов.
   - **Функция (Доменная логика)**: Определяет, что является важным для бизнеса, и реализует основные правила и ограничения, которые должны соблюдаться для каждой сущности.
   - **Зачем это нужно**: Доменная логика формирует "язык" и правила приложения, что позволяет точно описывать и поддерживать бизнес-правила.
   - **Пример**: Если мы создаем сущность `User`, она может иметь поля `id`, `name`, `email`, а также метод `activate()`, который активирует пользователя.

### 2. **Repositories (Репозитории, Infrastructure Logic)**

   - **Описание**: Репозитории выступают в роли абстракции над базой данных и отвечают за сохранение и извлечение сущностей. Они скрывают детали работы с базой данных от остальной части приложения.
   - **Реализация**: В папке `infra` находятся классы, реализующие интерфейсы для взаимодействия с базой данных или другими источниками данных. Например, `UserRepository` будет содержать методы `save(user)`, `find_by_id(user_id)` и т.д.
   - **Функция (Инфраструктурная логика)**: Инфраструктурная логика отделяет бизнес-логику от деталей хранения данных, предоставляя абстракцию для работы с данными.
   - **Зачем это нужно**: Изоляция инфраструктуры позволяет легко заменять источники данных или способы хранения, например, при смене базы данных или миграции на другую систему.
   - **Пример**: `UserRepository` может содержать методы для сохранения пользователей или получения их по `id`, не вникая в то, какая именно база данных используется.

### 3. **Services (Сервисы, Business Logic)**

   - **Описание**: Сервисы содержат бизнес-логику, которая не привязана к конкретной сущности. Они используют сущности и репозитории для выполнения задач.
   - **Реализация**: В папке `logic` находятся классы, которые решают бизнес-задачи, такие как обработка заказа или регистрация пользователя. Эти сервисы принимают объекты сущностей, работают с репозиториями для сохранения данных и могут вызывать другие сервисы.
   - **Функция (Бизнесовая логика)**: Организует бизнес-процессы, определяет логику, связанную с несколькими сущностями, и координирует действия между ними.
   - **Зачем это нужно**: Сохранение бизнес-логики отдельно позволяет легко изменять и адаптировать процессы приложения, не затрагивая другие уровни.
   - **Пример**: Сервис `OrderService` может содержать метод `place_order(user, items)`, который создает заказ для пользователя, проверяет наличие товара и сохраняет заказ через `OrderRepository`.

### 4. **Entrypoints (Точки входа, Application Logic)**

   - **Описание**: Точки входа — это компоненты, которые взаимодействуют с внешним миром, например, принимают запросы API и передают их на обработку в сервисы.
   - **Реализация**: В папке `application` находятся файлы, которые определяют маршруты API, контроллеры, обработчики запросов и другие компоненты, необходимые для взаимодействия с пользователем.
   - **Функция (Прикладная логика)**: Получает запросы от пользователей или внешних систем, направляет их в соответствующие сервисы и обрабатывает ответы.
   - **Зачем это нужно**: Прикладная логика отделяет взаимодействие с пользователями от внутренних бизнес-процессов, что делает приложение более устойчивым к изменениям в интерфейсе и упрощает управление запросами.
   - **Пример**: Например, файл `user_controller.py` может содержать маршрут `/register`, который принимает POST-запрос с данными пользователя, передает их в `UserService` и возвращает ответ.

### Зачем такая структура

Эта структура позволяет легко масштабировать проект, добавляя новые функциональные компоненты, не нарушая других частей приложения. Четкое разделение уровней логики — доменная, инфраструктурная, бизнесовая и прикладная — делает приложение гибким и удобным в поддержке. Каждый уровень выполняет свою задачу независимо от других, что упрощает тестирование и внесение изменений.

### Простой пример, как ребенку

Представь, что у нас есть школа. Школа — это наше приложение. У нас есть разные комнаты:

1. **Сущности (Entities)** — это наши ученики. У каждого ученика есть свое имя, возраст и класс.
2. **Репозитории (Repositories)** — это шкафчики, где хранятся данные о учениках, например, их оценки и домашние задания. Эти шкафчики помогают найти нужную информацию об ученике.
3. **Сервисы (Services)** — это учителя. Учителя обучают учеников и решают разные задачи, например, проводят уроки и проверяют задания.
4. **Точки входа (Entrypoints)** — это дверь в школу, через которую приходят запросы. Когда ученик хочет войти в школу, он проходит через дверь, чтобы получить доступ к урокам и учителям.

5. **Медиатор (Mediator)** — это директор школы, который направляет учеников к нужным учителям, в зависимости от того, какая у них задача. Если ученик хочет выучить новый предмет, директор направляет его к соответствующему учителю. Если у ученика есть конкретный вопрос, директор отправляет его к учителю, который может помочь.
---
- Таким образом, каждый компонент выполняет свою роль, как в настоящей школе, чтобы все работало слаженно и без сбоев.

- Таким образом, директор (медиатор) помогает организовать взаимодействие между учениками (командами) и учителями (обработчиками), чтобы всё работало слаженно и ученики не обращались напрямую к разным учителям, создавая путаницу. Медиатор координирует, кто куда должен идти, обеспечивая порядок и упрощая взаимодействие.






